{"majorversion": 3, "classmap": {"MultiObject": {"name": "MultiObject", "constructors": [{"params": [{"type": "Array", "name": "items", "description": "  initial set of items"}, {"type": "Object", "name": "config", "description": "  configuration\n<dl>\n<dt>return_all_results</dt>\n<dd>Default: false.  If this is true, then all delegated functions\nwill return an array of results instead of the result from the\nprimary item.  Note that functions which return \"undefined\" or\nthe item itself always cause the MultiObject to be returned,\nto support chaining.</dd>\n<dt>primary_item_index</dt>\n<dd>Default: 0.  When return_all_results=false, this is the index of\nthe item which generates the return result for all delegated\nfunctions.</dd>\n</dl>"}], "description": "<p>MultiObject exposes exactly the same API as each individual object,\nboth functions and events, and the state of all the objects is kept in\nsync.  The objects must maintain all state via\nY.Attribute.<p>\n<p>MultiObject is similar to Y.ArrayList, except:</p>\n<ul>\n<li>All objects must be of the same type, since MultiObject is supposed\nto behave exactly like any single object.</li>\n<li>MultiObject automatically delegates all methods.</li>\n<li>By default, MultiObject returns the result from the first object\nin the list, not an array of results.</li>\n<li>MultiObject propagates all events.</li>\n</ul>\n<p>Internally, MultiObject delegates all methods by name, so it supports\nY.Do.before, Y.Do.after, etc.</p>\n<p>To avoid shadowing potential function names, we inherit from\nY.EventTarget and use multi_ as the prefix for our own functions.</p>"}], "namespace": "", "module": "gallery-multiobject", "methods": {"multi_get_primary_item_index": {"return": {"type": "", "description": "the index of the primary item"}, "guessedname": "multi_get_primary_item_index", "guessedtype": "function"}, "multi_set_primary_item_index": {"params": [{"type": "int", "name": "index", "description": "  the index of the primary item"}], "guessedname": "multi_set_primary_item_index", "guessedtype": "function"}, "multi_destroy": {"description": "Destroys the MultiObject, but not the individual objects.\n<code>destroy()</code> is, of course, delegated.", "guessedname": "multi_destroy", "guessedtype": "function"}, "multi_get_return_all_results": {"return": {"type": "", "description": "true if all results will be returned by delegated functions"}, "guessedname": "multi_get_return_all_results", "guessedtype": "function"}, "multi_get_all": {"return": {"type": "Array", "description": "results from delegating the named function"}, "params": [{"type": "String", "name": "f", "description": "  name of the function to invoke"}, {"type": "mixed", "name": "arg*", "description": "  0..n arguments to pass to the function"}], "description": "Return an array of all the individual results from calling the\nspecified function.  This is only useful if return_all_results=false.", "guessedname": "multi_get_all", "guessedtype": "function"}, "multi_set_return_all_results": {"params": [{"type": "boolean", "name": "all", "description": "  true if delegated functions should return all results"}], "guessedname": "multi_set_return_all_results", "guessedtype": "function"}}, "file": "MultiObject.js", "shortname": "MultiObject", "description": "<p>MultiObject exposes exactly the same API as each individual object,\nboth functions and events, and the state of all the objects is kept in\nsync.  The objects must maintain all state via\nY.Attribute.<p>\n<p>MultiObject is similar to Y.ArrayList, except:</p>\n<ul>\n<li>All objects must be of the same type, since MultiObject is supposed\nto behave exactly like any single object.</li>\n<li>MultiObject automatically delegates all methods.</li>\n<li>By default, MultiObject returns the result from the first object\nin the list, not an array of results.</li>\n<li>MultiObject propagates all events.</li>\n</ul>\n<p>Internally, MultiObject delegates all methods by name, so it supports\nY.Do.before, Y.Do.after, etc.</p>\n<p>To avoid shadowing potential function names, we inherit from\nY.EventTarget and use multi_ as the prefix for our own functions.</p>"}}, "version": "1.0.0", "modules": {"gallery-multiobject": {"description": "<p>MultiObject exposes exactly the same API as each individual object,\nboth functions and events, and the state of all the objects is kept in\nsync.  The objects must maintain all state via\nY.Attribute.<p>\n<p>MultiObject is similar to Y.ArrayList, except:</p>\n<ul>\n<li>All objects must be of the same type, since MultiObject is supposed\nto behave exactly like any single object.</li>\n<li>MultiObject automatically delegates all methods.</li>\n<li>By default, MultiObject returns the result from the first object\nin the list, not an array of results.</li>\n<li>MultiObject propagates all events.</li>\n</ul>\n<p>Internally, MultiObject delegates all methods by name, so it supports\nY.Do.before, Y.Do.after, etc.</p>\n<p>To avoid shadowing potential function names, we inherit from\nY.EventTarget and use multi_ as the prefix for our own functions.</p>", "submodules": [], "classlist": ["MultiObject"], "filelist": ["MultiObject.js"], "subdata": {}, "name": "gallery-multiobject"}}, "filemap": {"MultiObject.js": {"classlist": ["MultiObject"], "name": "MultiObject.js", "module": "gallery-multiobject"}}}